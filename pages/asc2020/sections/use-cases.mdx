# Use cases for making things more dynamic

## Why would we do this?

### We want reusability

We add keywords like `$ref` to specifications to help people make things reusable. We want to define once and reuse all over.

```yaml:geneva-context
show:
  scope: true
  definition: true
  result: true
scope:
  info:
    contact:
      name: API Support
      url: http://www.example.com/support
      email: support@example.com
definition:
  openapi: 3.0.0
  info: ref:info
```

This differs from `$ref` that we find in OpenAPI and JSON Schema. The `ref` here is referencing a variable in the current scope. Geneva lets you define variables and reuse them through the entire definition. This means Geneva's `ref` and `$ref` can be used together.

```yaml:geneva-context
show:
  scope: true
  definition: true
  result: true
scope:
  customerRef: https://example.com/customer.yml
definition:
  openapi: 3.0.0
  components:
    Customer:
      $ref: ref:customerRef
```

### We want to compose files together

Left untended, YAML documents grow in complexity and size. It's not easy to read or edit a 10,000 line YAML document. The next step is to break files like this into multiple files.

```yaml:geneva-context
show:
  files: true
  definition: true
  result: true
files:
  infoFile: |
    contact:
      name: API Support
      url: http://www.example.com/support
      email: support@example.com
definition:
  openapi: 3.0.0
  info:
    fn:include: "infoFile"
```

Imagine including Markdown files that technical writers put together. Or security definitions managed by the security team. Or operations defined in a separate file.

### We want localization

Similarly, people may want to add localization to their OpenAPI definition. Instead of adding localization to the OpenAPI specification, people could pass in different languages to build separate final OpenAPI definitions.

```yaml:geneva-context
show:
  scope: true
  definition: true
  result: true
scope:
  lang: en
  locale:
    getCustomerDescription:
      en: Get customer
    createCustomerDescription:
      en: Create customer
  getLocale:
    fn:lambda:
      - [term]
      - fn:path:
          - - ref:term
            - ref:lang
          - ref:locale
definition:
  openapi: 3.0.0
  paths:
    /customers:
      get:
        description:
          fn:getLocale: getCustomerDescription
      post:
        description:
          fn:getLocale: createCustomerDescription
```

### We want base definitions

Sometimes we want to add certain status codes to every response in an OpenAPI definition. This happens for error codes that all return the same error format.

```yaml:geneva-context
show:
  scope: true
  definition: true
  result: true
scope:
  postResponses:
    fn:lambda:
      - [responses]
      - fn:mergeDeepLeft:
          - responses:
              "405":
                description: Method Not Allowed
                content:
                  "application/json": {}
          - ref:responses
definition:
  openapi: 3.0.0
  paths:
    /customers:
      post:
        fn:postResponses:
          responses:
            "200":
              description: Customer added
              content:
                "application/json": {}
```

### We want safety

The Python implementation of YAML has a function called `safe_load`. This is because [YAML is inherently unsafe](https://www.arp242.net/yaml-config.html). It's not safe either to accept arbitrary code. We add functions in YAML for this reason.
